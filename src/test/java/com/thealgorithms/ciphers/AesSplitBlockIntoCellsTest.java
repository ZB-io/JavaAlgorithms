
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model

ROOST_METHOD_HASH=splitBlockIntoCells_3071ee55e5
ROOST_METHOD_SIG_HASH=splitBlockIntoCells_6d08d743a1

"""
Scenario 1: Normal Case with 128-bit input

Details:
  TestName: testSplitting128BitInteger
  Description: This test will validate the normal operation of the method, splitting a full 128-bit integer into 8-bit cells.
Execution:
  Arrange: Create a BigInteger with a 128-bit value.
  Act: Invoke splitBlockIntoCells with the arranged BigInteger as parameter.
  Assert: The result should match the expected array of 8-bit integers.
Validation:
  The assertion verifies that the input 128-bit integer is correctly separated into 16 8-bit integers.
  This is critical as it is the basic functionality of the method and the precondition for any further operations.

Scenario 2: Testing with a BigInteger less than 128-bit

Details:
  TestName: testSplittingLessThan128BitInteger
  Description: This test is meant to check the method behavior when the BigInteger to be split is less than the 128-bits.
Execution:
  Arrange: Create a BigInteger with a value less than 128-bits.
  Act: Invoke splitBlockIntoCells with the arranged BigInteger as parameter.
  Assert: The result should match the expected array of 8-bit integers, with leading cells containing 0s.
Validation:
  The assertion checks that the method correctly handles inputs of less than 128-bits, correctly padding the result with leading 0s.
  Correct handling of inputs of different lengths is essential for flexible operation of the method.

Scenario 3: Testing with a BigInteger of Zero

Details:
  TestName: testSplittingZeroBitInteger
  Description: This test is to check the method behavior when the BigInteger to be split is Zero.
Execution:
  Arrange: Create a BigInteger with a value of zero.
  Act: Invoke splitBlockIntoCells with the arranged BigInteger as parameter.
  Assert: The result should match an array of zero-filled 8-bit integers.
Validation:
  The assertion verifies that the method correctly handles an input of zero, returning an array of zero-filled 8-bit integers.
  This is important as it confirms the correct operation of the method when faced with edge cases.
"""
*/

// ********RoostGPT********

package com.thealgorithms.ciphers;

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import java.math.BigInteger;
import org.junit.jupiter.api.*;
import java.util.Scanner;

class AesSplitBlockIntoCellsTest {

	@Test
	@Tag("valid")
	void testSplitting128BitInteger() {
		// Arrange
		BigInteger block = new BigInteger("ffffffffffffffffffffffffffffffff", 16);
		int[] expected = new int[] { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
		// Act
		int[] result = AES.splitBlockIntoCells(block);
		// Assert
		assertArrayEquals(expected, result);
	}

	@Test
	@Tag("boundary")
	void testSplittingLessThan128BitInteger() {
		// Arrange
		BigInteger block = new BigInteger("f", 16);
		int[] expected = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15 };
		// Act
		int[] result = AES.splitBlockIntoCells(block);
		// Assert
		assertArrayEquals(expected, result);
	}

	@Test
	@Tag("boundary")
	void testSplittingZeroBitInteger() {
		// Arrange
		BigInteger block = BigInteger.ZERO;
		int[] expected = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		// Act
		int[] result = AES.splitBlockIntoCells(block);
		// Assert
		assertArrayEquals(expected, result);
	}

}