
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model

ROOST_METHOD_HASH=storeAllPaths_5448c785f8
ROOST_METHOD_SIG_HASH=storeAllPaths_0b9f8673ad

"""
  Scenario 1: Test the method with valid source and destination
  Details:
    TestName: testStoreAllPathsWithValidSourceAndDestination
    Description: This test will verify if the method can find all paths from a valid source to a valid destination.
  Execution:
    Arrange: Create an instance of the AllPathsFromSourceToTarget class. Define source and destination locations as two distinct nodes within the graph.
    Act: Call the method storeAllPaths with source and destination as parameters.
    Assert: Assert that the result is as expected.
  Validation:
    This test validates that the function correctly finds all possible paths between two valid nodes in the graph. The expected behavior is that the method will return all the possible paths from source to destination.

  Scenario 2: Test the method when the source and destination are the same
  Details:
    TestName: testStoreAllPathsWithSameSourceAndDestination
    Description: This test will verify if the method handles the case where the source and destination are the same node.
  Execution:
    Arrange: Create an instance of the AllPathsFromSourceToTarget class. Define source and destination as the same node.
    Act: Call the method storeAllPaths with source and destination as parameters.
    Assert: Assert that the result is as expected.
  Validation:
    This test validates that the function correctly handles the case where the source and destination nodes are the same. The expected result is a list that contains a single path that is just the source node.

  Scenario 3: Test the method with an invalid source (node that does not exist in the graph)
  Details:
    TestName: testStoreAllPathsWithInvalidSource
    Description: This test will verify if the method handles the case where the source does not exist in the graph.
  Execution:
    Arrange: Create an instance of the AllPathsFromSourceToTarget class. Define the source as a node that does not exist in the graph.
    Act: Call the method storeAllPaths with the invalid source and a valid destination as parameters.
    Assert: Assert that the result is as expected.
  Validation:
    This test validates that the method correctly handles the case where the source node does not exist in the graph. The expected behavior is that the method will throw an exception.

  Scenario 4: Test the method with an invalid destination (node that does not exist in the graph)
  Details:
    TestName: testStoreAllPathsWithInvalidDestination
    Description: This test will verify if the method handles the case where the destination does not exist in the graph.
  Execution:
    Arrange: Create an instance of the AllPathsFromSourceToTarget class. Define the destination as a node that does not exist in the graph.
    Act: Call the method storeAllPaths with a valid source and the invalid destination as parameters.
    Assert: Assert that the result is as expected.
  Validation:
    This test validates that the function correctly handles the case where the destination node does not exist in the graph. The expected behavior is that the method will throw an exception.
"""
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.*;

public class AllPathsFromSourceToTargetStoreAllPathsTest {

	@Test
	@Tag("valid")
	public void testStoreAllPathsWithValidSourceAndDestination() {
		AllPathsFromSourceToTarget allPaths = new AllPathsFromSourceToTarget(3);
		allPaths.addEdge(0, 1);
		allPaths.addEdge(0, 2);
		allPaths.addEdge(1, 2);
		allPaths.addEdge(2, 0);
		allPaths.addEdge(2, 1);
		allPaths.addEdge(1, 0);
		int source = 0;
		int destination = 2;
		allPaths.storeAllPaths(source, destination);
		List<List<Integer>> expectedOut = Arrays.asList(Arrays.asList(0, 2), Arrays.asList(0, 1, 2));
		assertThat(allPaths.nm).isEqualTo(expectedOut);
	}

	@Test
	@Tag("valid")
	public void testStoreAllPathsWithSameSourceAndDestination() {
		AllPathsFromSourceToTarget allPaths = new AllPathsFromSourceToTarget(2);
		allPaths.addEdge(0, 1);
		int source = 0;
		allPaths.storeAllPaths(source, source);
		List<List<Integer>> expectedOut = Arrays.asList(Arrays.asList(0));
		assertThat(allPaths.nm).isEqualTo(expectedOut);
	}

	@Test
	@Tag("invalid")
	public void testStoreAllPathsWithInvalidSource() {
		AllPathsFromSourceToTarget allPaths = new AllPathsFromSourceToTarget(2);
		allPaths.addEdge(0, 1);
		int invalidSource = 3;
		int destination = 1;
		assertThrows(IndexOutOfBoundsException.class, () -> {
			allPaths.storeAllPaths(invalidSource, destination); // The invalid source node
																// doesn't exist in the
																// graph
		});
	}

	@Test
	@Tag("invalid")
	public void testStoreAllPathsWithInvalidDestination() {
		AllPathsFromSourceToTarget allPaths = new AllPathsFromSourceToTarget(2);
		allPaths.addEdge(0, 1);
		int source = 0;
		int invalidDestination = 3;
		assertThrows(IndexOutOfBoundsException.class, () -> {
			allPaths.storeAllPaths(source, invalidDestination); // The invalid destination
																// node doesn't exist in
																// the graph
		});
	}

}