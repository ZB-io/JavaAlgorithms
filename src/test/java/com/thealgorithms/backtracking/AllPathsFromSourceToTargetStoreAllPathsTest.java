

// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=storeAllPaths_5448c785f8
ROOST_METHOD_SIG_HASH=storeAllPaths_0b9f8673ad

"""
Scenario 1: Test the method with valid source and destination nodes

Details:  
  TestName: testWithValidSourceAndDestination.
  Description: This test is meant to check the method's ability to correctly store all paths from the source node to the destination node. The graph is initialized with a certain number of vertices and edges.
Execution:
  Arrange: Set up a graph with a defined number of vertices and edges. Define a valid source node and a destination node.
  Act: Invoke the storeAllPaths method with the source and destination nodes.
  Assert: Use JUnit assertions to compare the actual paths stored with the expected paths.
Validation: 
  The assertion aims to verify that the method correctly stores all the paths from the source node to the destination node. The test confirms the method's correctness in the context of the graph traversal logic.

Scenario 2: Test the method with source node equals to the destination node

Details:  
  TestName: testWithSourceEqualsDestination.
  Description: This test is intended to check the method's behavior when the source and destination nodes are the same. According to the graph traversal logic, there should be only one path from a node to itself.
Execution:
  Arrange: Set up a graph with a defined number of vertices and edges. Define the source node equals to the destination node.
  Act: Invoke the storeAllPaths method with the source and destination nodes.
  Assert: Use JUnit assertions to compare the actual paths stored with the expected path.
Validation: 
  The assertion aims to verify that the method correctly stores the path from a node to itself. The test confirms the method's correctness in this special case.

Scenario 3: Test the method when there is no path from the source node to the destination node

Details:  
  TestName: testWithNoPathFromSourceToDestination.
  Description: This test is meant to check the method's behavior when there is no path from the source node to the destination node. According to the graph traversal logic, the method should store no path in this case.
Execution:
  Arrange: Set up a graph with a defined number of vertices and edges such that there is no path from the source node to the destination node.
  Act: Invoke the storeAllPaths method with the source and destination nodes.
  Assert: Use JUnit assertions to compare the actual paths stored with the expected paths (which should be none).
Validation: 
  The assertion aims to verify that the method correctly handles the case where there is no path from the source node to the destination node. The test confirms the method's robustness in handling exceptional scenarios.

Scenario 4: Test the method with an empty graph

Details:  
  TestName: testWithEmptyGraph.
  Description: This test is intended to check the method's behavior when the graph is empty. According to the graph traversal logic, the method should store no path in this case.
Execution:
  Arrange: Set up an empty graph. Define any source node and destination node.
  Act: Invoke the storeAllPaths method with the source and destination nodes.
  Assert: Use JUnit assertions to compare the actual paths stored with the expected paths (which should be none).
Validation: 
  The assertion aims to verify that the method correctly handles the case where the graph is empty. The test confirms the method's robustness in handling exceptional scenarios.
"""
*/

// ********RoostGPT********

package com.thealgorithms.backtracking;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.List;
import java.util.ArrayList;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class AllPathsFromSourceToTargetStoreAllPathsTest {
    @Test
    @Tag("valid")
    public void testWithValidSourceAndDestination() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 2}, {2, 0}, {2, 3}, {3, 3}};
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(4);
        for (int[] edge : edges) {
          graph.addEdge(edge[0], edge[1]);
        }
        List<List<Integer>> expectedPaths = new ArrayList<>();
        expectedPaths.add(List.of(2, 0, 1));
        expectedPaths.add(List.of(2, 0, 3));
        expectedPaths.add(List.of(2, 3));
        List<List<Integer>> actualPaths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 2, 3);
        assertEquals(expectedPaths, actualPaths);
    }
    @Test
    @Tag("valid")
    public void testWithSourceEqualsDestination() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 2}, {2, 0}, {2, 3}, {3, 3}};
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(4);
        for (int[] edge : edges) {
          graph.addEdge(edge[0], edge[1]);
        }
        List<List<Integer>> expectedPaths = new ArrayList<>();
        expectedPaths.add(List.of(1, 2));
        List<List<Integer>> actualPaths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 1, 1);
        assertEquals(expectedPaths, actualPaths);
    }
    @Test
    @Tag("invalid")
    public void testWithNoPathFromSourceToDestination() {
        int[][] edges = {{0, 1}, {0, 2}, {1, 2}, {2, 0}, {3, 3}};
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(4);
        for (int[] edge : edges) {
          graph.addEdge(edge[0], edge[1]);
        }
        List<List<Integer>> expectedPaths = new ArrayList<>();
        List<List<Integer>> actualPaths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 3, 1);
        assertEquals(expectedPaths, actualPaths);
    }
    @Test
    @Tag("invalid")
    public void testWithEmptyGraph() {
        int[][] edges = {};
        AllPathsFromSourceToTarget graph = new AllPathsFromSourceToTarget(4);
        List<List<Integer>> expectedPaths = new ArrayList<>();
        List<List<Integer>> actualPaths = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(4, edges, 0, 3);
        assertEquals(expectedPaths, actualPaths);
    }
}