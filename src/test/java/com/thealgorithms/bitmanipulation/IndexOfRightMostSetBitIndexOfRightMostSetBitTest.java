
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model

ROOST_METHOD_HASH=indexOfRightMostSetBit_59025c195c
ROOST_METHOD_SIG_HASH=indexOfRightMostSetBit_05d26edc31

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/6caf0f77-b77b-4c52-ace3-062c47fba289/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java
Tests:
    "@Test
@Test
void testIndexOfRightMostSetBit() {
    assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));
    assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));
    assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));
}
"Scenario 1: Test with negative number as input
Details:
  TestName: testWithNegativeNumber
  Description: This test validates the behavior of indexOfRightMostSetBit method when a negative number is passed as input and checks whether it returns the correct position of the rightmost set bit.
Execution:
  Arrange: No arrangement is necessary.
  Act: Call indexOfRightMostSetBit with a negative number, such as -20.
  Assert: Check that the result is 4.
Validation:
  "-20" in binary form is "11101100". The rightmost set bit is at position 4 from right. So, it is essential that function returns 4.

Scenario 2: Test with a positive number as input
Details:
  TestName: testWithPositiveNumber
  Description: This test validates the indexOfRightMostSetBit when a positive number is used as input. The function should return the correct position of the rightmost set bit.
Execution:
  Arrange: No arrangement required.
  Act: Call indexOfRightMostSetBit with a positive number, such as 12.
  Assert: Check that the result is 2.
Validation:
  "12" in binary form is "01010". Here, the rightmost set bit is at position 2 from right side. Therefore, it is crucial that function returns 2.

Scenario 3: Test with zero as input
Details:
  TestName: testWithZero
  Description: This test validates the method behavior when zero is used as input. As the binary representation of zero doesn't contain set bits, the function should return -1.
Execution:
  Arrange: No arrangement necessary.
  Act: Call indexOfRightMostSetBit with 0.
  Assert: Check that the result is -1.
Validation:
  As the binary representation of zero doesn't contain any set bits, function is expected to return -1. This test validates that behavior.

Scenario 4: Test with Power of Two Number
Details:
  TestName: testWithPowerOfTwo
  Description: This test will verify the method when the input is a power of 2, which has only one bit set.
Execution:
  Arrange: No arrangement needed.
  Act: Call indexOfRightMostSetBit with the number 16.
  Assert: Check that the result is 4.
Validation:
  The number 16 is "10000" in binary. The only set bit is at position 4 from right. Therefore, validation will cover whether return is 4.

Scenario 5: Test with the maximum integer value
Details:
  TestName: testWithMaxInteger
  Description: This test verifies the method when the maximum integer value is given as input.
Execution:
  Arrange: No preparation required.
  Act: Call indexOfRightMostSetBit with the maximum integer value (Integer.MAX_VALUE).
  Assert: Check that the result matches the expected output.
Validation:
  The method should be able to handle maximum values and return the correct location of the rightmost set bit. This test validates that the function is robust and handles edge cases properly.
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class IndexOfRightMostSetBitIndexOfRightMostSetBitTest {

	@Test
	@Tag("valid")
	public void testWithNegativeNumber() {
		int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(-20);
		assertEquals(4, result);
	}

	@Test
	@Tag("valid")
	public void testWithPositiveNumber() {
		int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(12);
		assertEquals(2, result);
	}

	@Test
	@Tag("valid")
	public void testWithZero() {
		int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(0);
		assertEquals(-1, result);
	}

	@Test
	@Tag("valid")
	public void testWithPowerOfTwo() {
		int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(16);
		assertEquals(4, result);
	}

	@Test
	@Tag("boundary")
	public void testWithMaxInteger() {
		// Max int value is 2147483647 and its binary form has last set bit at 0th
		// position from right side.
		int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(Integer.MAX_VALUE);
		assertEquals(0, result);
	}

}