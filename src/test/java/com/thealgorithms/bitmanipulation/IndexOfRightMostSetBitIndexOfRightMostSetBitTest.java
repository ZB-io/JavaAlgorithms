

// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=indexOfRightMostSetBit_59025c195c
ROOST_METHOD_SIG_HASH=indexOfRightMostSetBit_05d26edc31

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/26ab2638-dba2-485c-8149-06b142aca068/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java
Tests:
    "@Test
@Test
void testIndexOfRightMostSetBit() {
    assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));
    assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));
    assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));
}
"Scenario 1: Test with positive number having single set bit at index 0

Details:  
TestName: testWithSingleSetBitAtZeroIndex
Description: This test is meant to check the functionality of the method when the input number is a positive number having a single set bit at index 0. 
Execution:
Arrange: No setup is required as this is a static method. 
Act: Invoke the target method with input as 1.
Assert: Use JUnit assertions to compare the actual result with 0.
Validation: 
The assertion aims to verify that the function correctly identifies the rightmost set bit in the number. Since binary of 1 is 1 which has its rightmost set bit at index 0, the expected result is 0. 

Scenario 2: Test with negative number having single set bit at index 0

Details:  
TestName: testWithNegativeNumberAndSingleSetBitAtZeroIndex
Description: This test is meant to check the functionality of the method when the input number is a negative number having a single set bit at index 0. 
Execution:
Arrange: No setup is required as this is a static method. 
Act: Invoke the target method with input as -1.
Assert: Use JUnit assertions to compare the actual result with 0.
Validation: 
The assertion aims to verify that the function correctly identifies the rightmost set bit in the number. Since binary of -1 is 1 which has its rightmost set bit at index 0, the expected result is 0. 

Scenario 3: Test with large positive number

Details:  
TestName: testWithLargePositiveNumber
Description: This test is meant to check the functionality of the method when the input is a large positive number. 
Execution:
Arrange: No setup is required as this is a static method. 
Act: Invoke the target method with a large positive number.
Assert: Use JUnit assertions to compare the actual result with the expected index.
Validation: 
The assertion aims to verify that the function correctly identifies the rightmost set bit in the number. The expected result would be the index of the rightmost set bit in the binary representation of the input number.

Scenario 4: Test with large negative number

Details:  
TestName: testWithLargeNegativeNumber
Description: This test is meant to check the functionality of the method when the input is a large negative number. 
Execution:
Arrange: No setup is required as this is a static method. 
Act: Invoke the target method with a large negative number.
Assert: Use JUnit assertions to compare the actual result with the expected index.
Validation: 
The assertion aims to verify that the function correctly identifies the rightmost set bit in the number. The expected result would be the index of the rightmost set bit in the binary representation of the input number.
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class IndexOfRightMostSetBitIndexOfRightMostSetBitTest {
    @Test
    @Tag("valid")
    public void testWithSingleSetBitAtZeroIndex() {
        int n = 1;
        int expected = 0;
        int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("valid")
    public void testWithNegativeNumberAndSingleSetBitAtZeroIndex() {
        int n = -1;
        int expected = 0;
        int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("boundary")
    public void testWithLargePositiveNumber() {
        int n = Integer.MAX_VALUE;
        int expected = 0; // Because Integer.MAX_VALUE is odd number and rightmost set bit is at index 0
        int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("boundary")
    public void testWithLargeNegativeNumber() {
        int n = Integer.MIN_VALUE;
        int expected = 31; // Because Integer.MIN_VALUE is power of 2 and rightmost set bit is at index 31
        int actual = IndexOfRightMostSetBit.indexOfRightMostSetBit(n);
        assertEquals(expected, actual);
    }
}