

// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=indexOfRightMostSetBit_59025c195c
ROOST_METHOD_SIG_HASH=indexOfRightMostSetBit_05d26edc31

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/6027d49d-46d4-459b-bf2d-09388d3ac953/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java
Tests:
    "@Test
@Test
void testIndexOfRightMostSetBit() {
    assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));
    assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));
    assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));
}
"Scenario 1: Test with a Positive Number Having Single Set Bit
Details:  
  TestName: testWithSingleSetBitPositiveNumber
  Description: This test is meant to check the scenario where the input number is a positive integer having only a single set bit.
Execution:
  Arrange: No specific arrangement needed as the method is static and does not rely on any object's state.
  Act: Invoke the target method with a positive number having a single set bit, e.g., 16 (binary: 10000).
  Assert: Use JUnit assertions to check if the index of the rightmost set bit is as expected. In this case, it should be 4.
Validation: 
  The assertion verifies that our method correctly identifies the position of the rightmost set bit in a positive number with a single set bit. This is significant as it tests the method's basic functionality.

Scenario 2: Test with a Negative Number Having Multiple Set Bits
Details:  
  TestName: testWithMultipleSetBitsNegativeNumber
  Description: This test is meant to check the scenario where the input number is a negative integer having multiple set bits.
Execution:
  Arrange: No specific arrangement needed as the method is static and does not rely on any object's state.
  Act: Invoke the target method with a negative number having multiple set bits, e.g., -21 (binary: 10101).
  Assert: Use JUnit assertions to check if the index of the rightmost set bit is as expected. In this case, it should be 0.
Validation: 
  The assertion verifies that our method correctly identifies the position of the rightmost set bit in a negative number with multiple set bits. This is significant as it tests the method's ability to handle negative numbers and multiple set bits.

Scenario 3: Test with Maximum Integer Value
Details:  
  TestName: testWithMaxIntegerValue
  Description: This test is meant to check the scenario where the input number is the maximum integer value.
Execution:
  Arrange: No specific arrangement needed as the method is static and does not rely on any object's state.
  Act: Invoke the target method with the maximum integer value (Integer.MAX_VALUE).
  Assert: Use JUnit assertions to check if the index of the rightmost set bit is as expected.
Validation: 
  The assertion verifies that our method can handle the maximum integer value without any issues. This is significant as it tests the method's ability to handle edge cases.

Scenario 4: Test with Minimum Integer Value
Details:  
  TestName: testWithMinIntegerValue
  Description: This test is meant to check the scenario where the input number is the minimum integer value.
Execution:
  Arrange: No specific arrangement needed as the method is static and does not rely on any object's state.
  Act: Invoke the target method with the minimum integer value (Integer.MIN_VALUE).
  Assert: Use JUnit assertions to check if the index of the rightmost set bit is as expected.
Validation: 
  The assertion verifies that our method can handle the minimum integer value without any issues. This is significant as it tests the method's ability to handle edge cases.
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class IndexOfRightMostSetBitIndexOfRightMostSetBitTest {
    @Test
    @Tag("valid")
    public void testWithSingleSetBitPositiveNumber() {
        int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(16);
        assertEquals(4, result, "Rightmost set bit index should be 4 for number 16");
    }
    @Test
    @Tag("valid")
    public void testWithMultipleSetBitsNegativeNumber() {
        int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(-21);
        assertEquals(0, result, "Rightmost set bit index should be 0 for number -21");
    }
    @Test
    @Tag("boundary")
    public void testWithMaxIntegerValue() {
        int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(Integer.MAX_VALUE);
        assertEquals(0, result, "Rightmost set bit index should be 0 for max integer value");
    }
    @Test
    @Tag("boundary")
    public void testWithMinIntegerValue() {
        int result = IndexOfRightMostSetBit.indexOfRightMostSetBit(Integer.MIN_VALUE);
        assertEquals(31, result, "Rightmost set bit index should be 31 for min integer value");
    }
}