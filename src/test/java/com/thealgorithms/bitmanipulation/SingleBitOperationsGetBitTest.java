
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=getBit_487c75a4b3
ROOST_METHOD_SIG_HASH=getBit_2ea30e777d

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/6027d49d-46d4-459b-bf2d-09388d3ac953/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void getBitTest() {
    assertEquals(0, SingleBitOperations.getBit(6, 0));
    assertEquals(1, SingleBitOperations.getBit(7, 1));
}
""""
Scenario 1: Test to check the bit at the 0th index of a positive number
Details: 
  TestName: getBitAtZeroIndexPositiveNumber 
  Description: This test is meant to check the functionality of the getBit method when the bit to be retrieved is at the 0th index of a positive number. 
Execution:
  Arrange: No arrangement required as there are no dependencies.
  Act: Invoke getBit with a positive number and 0 as parameters.
  Assert: Use JUnit assertions to verify that the returned bit is as expected.
Validation: 
  The assertion aims to verify that the getBit method correctly retrieves the bit at the 0th index of a positive number. The expected result is based on binary representation of the number. This test is significant as it confirms the method's basic functionality with positive numbers.

Scenario 2: Test to check the bit at the nth index of a positive number
Details: 
  TestName: getBitAtNthIndexPositiveNumber 
  Description: This test is meant to check the functionality of the getBit method when the bit to be retrieved is at the nth index of a positive number.
Execution:
  Arrange: No arrangement required as there are no dependencies.
  Act: Invoke getBit with a positive number and n as parameters.
  Assert: Use JUnit assertions to verify that the returned bit is as expected.
Validation: 
  The assertion aims to verify that the getBit method correctly retrieves the bit at the nth index of a positive number. The expected result is based on binary representation of the number. This test is significant as it confirms the method's functionality with a variety of indices.

Scenario 3: Test to check the bit at the 0th index of a negative number
Details: 
  TestName: getBitAtZeroIndexNegativeNumber 
  Description: This test is meant to check the functionality of the getBit method when the bit to be retrieved is at the 0th index of a negative number. 
Execution:
  Arrange: No arrangement required as there are no dependencies.
  Act: Invoke getBit with a negative number and 0 as parameters.
  Assert: Use JUnit assertions to verify that the returned bit is as expected.
Validation: 
  The assertion aims to verify that the getBit method correctly retrieves the bit at the 0th index of a negative number. The expected result is based on binary representation of the number. This test is significant as it confirms the method's basic functionality with negative numbers.

Scenario 4: Test to check the bit at the nth index of a negative number
Details: 
  TestName: getBitAtNthIndexNegativeNumber 
  Description: This test is meant to check the functionality of the getBit method when the bit to be retrieved is at the nth index of a negative number.
Execution:
  Arrange: No arrangement required as there are no dependencies.
  Act: Invoke getBit with a negative number and n as parameters.
  Assert: Use JUnit assertions to verify that the returned bit is as expected.
Validation: 
  The assertion aims to verify that the getBit method correctly retrieves the bit at the nth index of a negative number. The expected result is based on binary representation of the number. This test is significant as it confirms the method's functionality with a variety of indices.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class SingleBitOperationsGetBitTest {
    @Test
    @Tag("valid")
    public void getBitAtZeroIndexPositiveNumber() {
        int num = 5;  // Binary representation: 101
        int bit = 0;
        int expected = 1;
        assertEquals(expected, SingleBitOperations.getBit(num, bit));
    }
    @Test
    @Tag("valid")
    public void getBitAtNthIndexPositiveNumber() {
        int num = 9;  // Binary representation: 1001
        int bit = 3;
        int expected = 1;
        assertEquals(expected, SingleBitOperations.getBit(num, bit));
    }
    @Test
    @Tag("valid")
    public void getBitAtZeroIndexNegativeNumber() {
        int num = -5;  // Binary representation: ...1011 (two's complement)
        int bit = 0;
        int expected = 1;
        assertEquals(expected, SingleBitOperations.getBit(num, bit));
    }
    @Test
    @Tag("valid")
    public void getBitAtNthIndexNegativeNumber() {
        int num = -9;  // Binary representation: ...0111 (two's complement)
        int bit = 3;
        int expected = 0;
        assertEquals(expected, SingleBitOperations.getBit(num, bit));
    }
}