
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=getBit_487c75a4b3
ROOST_METHOD_SIG_HASH=getBit_2ea30e777d

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/26ab2638-dba2-485c-8149-06b142aca068/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void getBitTest() {
    assertEquals(0, SingleBitOperations.getBit(6, 0));
    assertEquals(1, SingleBitOperations.getBit(7, 1));
}
""""
Scenario 1: Test to check the bit at position 0 in a positive number

Details:  
  TestName: testGetBitAtPositionZeroInPositiveNumber
  Description: This test is meant to check the functionality of the getBit method when the bit position is 0 and the number is positive. 
Execution:
  Arrange: No additional data or setup is required.
  Act: Invoke the getBit method with parameters num as a positive integer and bit as 0.
  Assert: Use JUnit assertions to compare the actual result with the expected result, which is the least significant bit of the integer.
Validation: 
  The assertion aims to verify that the getBit method correctly gets the bit at position 0 in a positive number. This test ensures the correctness of the method in handling positive numbers.

Scenario 2: Test to check the bit at position 0 in a negative number

Details:  
  TestName: testGetBitAtPositionZeroInNegativeNumber
  Description: This test is meant to check the functionality of the getBit method when the bit position is 0 and the number is negative. 
Execution:
  Arrange: No additional data or setup is required.
  Act: Invoke the getBit method with parameters num as a negative integer and bit as 0.
  Assert: Use JUnit assertions to compare the actual result with the expected result, which is the least significant bit of the integer.
Validation: 
  The assertion aims to verify that the getBit method correctly gets the bit at position 0 in a negative number. This test ensures the correctness of the method in handling negative numbers.

Scenario 3: Test to check the bit at a position greater than 0

Details:  
  TestName: testGetBitAtPositionGreaterThanZero
  Description: This test is meant to check the functionality of the getBit method when the bit position is greater than 0. 
Execution:
  Arrange: No additional data or setup is required.
  Act: Invoke the getBit method with parameters num as an integer and bit as an integer greater than 0.
  Assert: Use JUnit assertions to compare the actual result with the expected result, which is the bit at the specified position in the integer.
Validation: 
  The assertion aims to verify that the getBit method correctly gets the bit at a position greater than 0. This test ensures the correctness of the method in handling bit positions greater than 0.

Scenario 4: Test to check the bit at the maximum possible position

Details:  
  TestName: testGetBitAtMaxPosition
  Description: This test is meant to check the functionality of the getBit method when the bit position is the maximum possible position (31 for a 32-bit integer). 
Execution:
  Arrange: No additional data or setup is required.
  Act: Invoke the getBit method with parameters num as an integer and bit as 31.
  Assert: Use JUnit assertions to compare the actual result with the expected result, which is the bit at the 31st position in the integer.
Validation: 
  The assertion aims to verify that the getBit method correctly gets the bit at the maximum possible position. This test ensures the correctness of the method in handling bit positions at the maximum limit.

Scenario 5: Test to check the bit at a position greater than the maximum possible position

Details:  
  TestName: testGetBitAtPositionGreaterThanMax
  Description: This test is meant to check the functionality of the getBit method when the bit position is greater than the maximum possible position (31 for a 32-bit integer). 
Execution:
  Arrange: No additional data or setup is required.
  Act: Invoke the getBit method with parameters num as an integer and bit as an integer greater than 31.
  Assert: Use JUnit assertions to compare the actual result with the expected result, which should be 0 as the bit position is out of range.
Validation: 
  The assertion aims to verify that the getBit method correctly gets the bit at a position greater than the maximum possible position. This test ensures the correctness of the method in handling bit positions that are out of range.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class SingleBitOperationsGetBitTest {
    @Test
    @Tag("valid")
    public void testGetBitAtPositionZeroInPositiveNumber() {
        int num = 2;  // 0010 in binary
        int bit = 0;
        int expected = 0;  // The bit at position 0 in 0010 is 0
        int actual = SingleBitOperations.getBit(num, bit);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("valid")
    public void testGetBitAtPositionZeroInNegativeNumber() {
        int num = -2;  // 1110 in binary (two's complement)
        int bit = 0;
        int expected = 0;  // The bit at position 0 in 1110 is 0
        int actual = SingleBitOperations.getBit(num, bit);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("valid")
    public void testGetBitAtPositionGreaterThanZero() {
        int num = 5;  // 0101 in binary
        int bit = 2;
        int expected = 1;  // The bit at position 2 in 0101 is 1
        int actual = SingleBitOperations.getBit(num, bit);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("boundary")
    public void testGetBitAtMaxPosition() {
        int num = Integer.MIN_VALUE;  // 1000 0000 0000 0000 0000 0000 0000 0000
        int bit = 31;
        int expected = 1;  // The bit at position 31 in the above number is 1
        int actual = SingleBitOperations.getBit(num, bit);
        assertEquals(expected, actual);
    }
    @Test
    @Tag("invalid")
    public void testGetBitAtPositionGreaterThanMax() {
        int num = 5;  // 0101 in binary
        int bit = 32;
        int expected = 0;  // The bit at position 32 does not exist, so it should return 0
        int actual = SingleBitOperations.getBit(num, bit);
        assertEquals(expected, actual);
    }
}