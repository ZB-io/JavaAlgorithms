
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=flipBit_cc971e4a99
ROOST_METHOD_SIG_HASH=flipBit_219935ae9f

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/26ab2638-dba2-485c-8149-06b142aca068/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void flipBitTest() {
    assertEquals(1, SingleBitOperations.flipBit(3, 1));
    assertEquals(11, SingleBitOperations.flipBit(3, 3));
}
""""
  Scenario 1: Test to flip the least significant bit in a number

  Details:  
    TestName: flipLeastSignificantBit.
    Description: The test is meant to check the functionality of flipping the least significant bit (0th position) in a number. 
  Execution:
    Arrange: No setup required.
    Act: Invoke flipBit with a number and 0 as the bit position.
    Assert: Check if the returned number has the least significant bit flipped.
  Validation: 
    The assertion verifies that the least significant bit is correctly flipped. The expected result is based on the bitwise operation of XOR.

  Scenario 2: Test to flip a bit in a negative number

  Details:  
    TestName: flipBitInNegativeNumber.
    Description: This test checks the capability of the flipBit method to handle negative numbers.
  Execution:
    Arrange: No setup required.
    Act: Invoke flipBit with a negative number and a bit position.
    Assert: Check if the returned number has the specified bit flipped.
  Validation: 
    The test verifies that the method can correctly flip a bit in a negative number. The expected result is based on the bitwise operation of XOR. 

  Scenario 3: Test to flip a non-existing bit in a number

  Details:  
    TestName: flipNonExistingBit.
    Description: The test is intended to check the behavior of the flipBit method when asked to flip a bit that does not exist in the binary representation of the number.
  Execution:
    Arrange: No setup required.
    Act: Invoke flipBit with a number and a bit position that does not exist in the number's binary form.
    Assert: Check if the returned number has the non-existing bit flipped (i.e. a new bit is created at the position).
  Validation: 
    The assertion verifies that the method can correctly flip a non-existing bit, effectively adding a new bit at the specified position. The expected result is based on the bitwise operation of XOR. 

  Scenario 4: Test to flip a bit in zero

  Details:  
    TestName: flipBitInZero.
    Description: This test checks the flipBit method's ability to handle zero as the input number.
  Execution:
    Arrange: No setup required.
    Act: Invoke flipBit with 0 as the number and a bit position.
    Assert: Check if the returned number has the specified bit flipped.
  Validation: 
    The test verifies that the method can correctly flip a bit in zero. The expected result is based on the bitwise operation of XOR.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;

public class SingleBitOperationsFlipBitTest {
    @Test
    @Tag("valid")
    public void flipLeastSignificantBit() {
        int num = 5; // binary: 101
        int bit = 0;
        int expected = 4; // binary: 100
        assertEquals(expected, SingleBitOperations.flipBit(num, bit));
    }
    @Test
    @Tag("valid")
    public void flipBitInNegativeNumber() {
        int num = -5; // binary: -101
        int bit = 1;
        int expected = -7; // binary: -111
        assertEquals(expected, SingleBitOperations.flipBit(num, bit));
    }
    @Test
    @Tag("valid")
    public void flipNonExistingBit() {
        int num = 5; // binary: 101
        int bit = 3;
        int expected = 13; // binary: 1101
        assertEquals(expected, SingleBitOperations.flipBit(num, bit));
    }
    @Test
    @Tag("boundary")
    public void flipBitInZero() {
        int num = 0; // binary: 0
        int bit = 2;
        int expected = 4; // binary: 100
        assertEquals(expected, SingleBitOperations.flipBit(num, bit));
    }
}