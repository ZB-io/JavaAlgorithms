
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model 

ROOST_METHOD_HASH=flipBit_cc971e4a99
ROOST_METHOD_SIG_HASH=flipBit_219935ae9f

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/6027d49d-46d4-459b-bf2d-09388d3ac953/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void flipBitTest() {
    assertEquals(1, SingleBitOperations.flipBit(3, 1));
    assertEquals(11, SingleBitOperations.flipBit(3, 3));
}
"Scenario 1: Flip a bit at the start of the number
Details:
  TestName: flipBitAtStart
  Description: This test checks the functionality of flipping the first bit of a given integer.
  Execution:
    Arrange: Initialize an integer with a binary representation where the first bit is 1.
    Act: Call the flipBit method with the number and position 0 as parameters.
    Assert: Assert that the returned integer has its first bit flipped.
  Validation: 
    The assertion verifies that the first bit of the number has been successfully flipped. In the context of binary operations, this test ensures that the method can properly handle and flip bits at the start of a number.

Scenario 2: Flip a bit at the end of the number
Details:
  TestName: flipBitAtEnd
  Description: This test checks the functionality of flipping the last bit of a given integer.
  Execution:
    Arrange: Initialize an integer with a binary representation where the last bit is 1.
    Act: Call the flipBit method with the number and the last position as parameters.
    Assert: Assert that the returned integer has its last bit flipped.
  Validation: 
    The assertion verifies that the last bit of the number has been successfully flipped. This is important in verifying that the method can handle and flip bits at the end of a number.

Scenario 3: Flip a bit in the middle of the number
Details:
  TestName: flipBitInMiddle
  Description: This test checks the functionality of flipping a bit in the middle of a given integer.
  Execution:
    Arrange: Initialize an integer with a binary representation where a middle bit is 1.
    Act: Call the flipBit method with the number and the middle position as parameters.
    Assert: Assert that the returned integer has its middle bit flipped.
  Validation: 
    The assertion verifies that the middle bit of the number has been successfully flipped. This is crucial in verifying that the method can handle and flip bits at any position in a number.

Scenario 4: Flip a bit in an all-zero number
Details:
  TestName: flipBitInAllZeroNumber
  Description: This test checks the functionality of the flipBit method when the number is all zeros.
  Execution:
    Arrange: Initialize an integer with all bits as 0.
    Act: Call the flipBit method with the number and any position as parameters.
    Assert: Assert that the returned integer has the bit at the specified position flipped to 1.
  Validation: 
    The assertion verifies that the method can successfully flip a bit in a number that is initially all zeros. This is essential to ensure that the method can handle edge cases where all bits are zeros.
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class SingleBitOperationsFlipBitTest {
    @Test
    @Tag("valid")
    public void flipBitAtStart() {
        final int num = 0b1000;  // 8 in binary
        final int bit = 3;  // bit position to flip
        int result = SingleBitOperations.flipBit(num, bit);
        assertEquals(0, result);
    }
    @Test
    @Tag("valid")
    public void flipBitAtEnd() {
        final int num = 0b0001;  // 1 in binary
        final int bit = 0;  // bit position to flip
        int result = SingleBitOperations.flipBit(num, bit);
        assertEquals(0, result);
    }
    @Test
    @Tag("valid")
    public void flipBitInMiddle() {
        final int num = 0b1010;  // 10 in binary
        final int bit = 1;  // bit position to flip
        int result = SingleBitOperations.flipBit(num, bit);
        assertEquals(8, result);
    }
    @Test
    @Tag("boundary")
    public void flipBitInAllZeroNumber() {
        final int num = 0b0000;  // 0 in binary
        final int bit = 2;  // bit position to flip
        int result = SingleBitOperations.flipBit(num, bit);
        assertEquals(4, result);
    }
}