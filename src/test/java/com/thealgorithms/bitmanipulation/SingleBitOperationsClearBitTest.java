
// ********RoostGPT********
/*
Test generated by RoostGPT for test OpenAII using AI Type  and AI Model

ROOST_METHOD_HASH=clearBit_2bb8df5689
ROOST_METHOD_SIG_HASH=clearBit_41db29e3ee

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/OpenAII/6caf0f77-b77b-4c52-ace3-062c47fba289/source/JavaAlgorithms/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void clearBitTest() {
    assertEquals(5, SingleBitOperations.clearBit(7, 1));
    assertEquals(5, SingleBitOperations.clearBit(5, 1));
}
""""
Scenario 1: Test for clearing the bit at position zero
Details:
  TestName: clearBitAtZeroPosition
  Description: This test is meant to check if the method correctly clears the bit at position 0 and returns the result.
Execution:
  Arrange: No data setup is required for this test as it's working with primitive data types.
  Act: Invoke the clearBit method with any number and bit position as 0.
  Assert: The result should be the original number minus 1 if the 0th bit was set.
Validation:
  This validates the basic functionality of the bit clearing feature for position zero. Zero position relates to the least significant bit hence widely used.

Scenario 2: Test for clearing the bit at position greater than the length of num
Details:
  TestName: clearBitAtPositionGreaterThanLength
  Description: This test is setup to check if the function correctly handles the case when the bit position is greater than the length of 'num'.
Execution:
  Arrange: No data setup is required for this test as it's working with primitive data types.
  Act: Invoke the clearBit method with bit position greater than the length of 'num'.
  Assert: As no change is made to beyond the length of 'num', the output should be same as 'num'.
Validation:
  This validates the function's ability to handle scenarios where the bit to be cleared lies beyond the length of 'num'.

Scenario 3: Test for clearing the bit at position within the length of num
Details:
  TestName: clearBitWithinBitLength
  Description: This test is meant to verify if the function correctly clears a bit within the length of 'num'.
Execution:
  Arrange: No data setup is required for this test as it's working with primitive data types.
  Act: Invoke the clearBit method with bit position less than length of 'num'.
  Assert: The result should be 'num' manipulated at the bit position provided.
Validation:
  This test validates that the function correctly clears a bit when its position lies within the binary representation of 'num'.

Scenario 4: Invalid scenario - Negative bit position
Details:
  TestName: negativeBitPosition
  Description: This test checks how the function handles negative bit positions, which is not a valid scenario.
Execution:
  Arrange: No data setup is required for this test as it's working with primitive data types.
  Act: Invoke the clearBit method with a negative bit position.
  Assert: There is no explicit handling of this scenario in the function, output will vary depending on how Java deals with negative shift operation.
Validation:
  This test indicates that there are no checks for negative bit positions, hence it might produce unexpected results. It serves as a feedback for improving function's robustness.

Scenario 5: Test for clearing bit for zero number
Details:
  TestName: clearBitForZero
  Description: This test is meant to verify if the function returns zero when 'num' is zero regardless of 'bit' position.
Execution:
  Arrange: No data setup is required for this test as it's working with primitive data types.
  Act: Invoke the clearBit method with 'num' as zero.
  Assert: The result should be zero.
Validation:
  This test validates that the function correctly handles edge case when 'num' is zero. The output should always be zero as there are no bits set.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.*;

public class SingleBitOperationsClearBitTest {

	@Test
	@Tag("valid")
	public void clearBitAtZeroPosition() {
		// Act
		int result = SingleBitOperations.clearBit(5, 0);
		// 5 represented as binary is 101, and clearing the 0th bit changes it to 100 or 4
		// in decimal
		// Assert
		Assertions.assertThat(result).isEqualTo(4);
	}

	@Test
	@Tag("valid")
	public void clearBitAtPositionGreaterThanLength() {
		// Act
		int result = SingleBitOperations.clearBit(5, 8);
		// The binary representation of 5 doesn't have 8 bits, so nothing happens and the
		// number stays 5
		// Assert
		Assertions.assertThat(result).isEqualTo(5);
	}

	@Test
	@Tag("valid")
	public void clearBitWithinBitLength() {
		// Act
		int result = SingleBitOperations.clearBit(13, 2);
		// 13 represented as binary is 1101, and clearing the 2nd bit changes it to 1001
		// or 9 in decimal
		// Assert
		Assertions.assertThat(result).isEqualTo(9);
	}

	@Test
	@Tag("invalid")
	public void negativeBitPosition() {
		// Act
		int result = SingleBitOperations.clearBit(5, -1);
		// No assertion can be made as the behavior is undefined
	}

	@Test
	@Tag("boundary")
	public void clearBitForZero() {
		// Act
		int result = SingleBitOperations.clearBit(0, 5);
		// It remains 0, no matter what the position is because there are no bits set
		// Assert
		Assertions.assertThat(result).isEqualTo(0);
	}

}